{"version":3,"sources":["../src/rar-files-package.ts","../src/rar-file-bundle.ts","../src/rar-file-chunk.ts","../src/inner-file-stream.ts","../src/stream-utils.ts","../src/utils.ts","../src/inner-file.ts","../src/parsing/marker-header-parser.ts","../src/parsing/archive-header-parser.ts","../src/parsing/file-header-parser.ts","../src/parsing/terminator-header-parser.ts","../src/local-file-media.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { makeRarFileBundle, RarFileBundle } from \"./rar-file-bundle.js\";\nimport { RarFileChunk } from \"./rar-file-chunk.js\";\nimport { InnerFile } from \"./inner-file.js\";\n\nimport { MarkerHeaderParser } from \"./parsing/marker-header-parser.js\";\nimport { ArchiveHeaderParser } from \"./parsing/archive-header-parser.js\";\nimport { FileHeaderParser, IFileHeader } from \"./parsing/file-header-parser.js\";\nimport { TerminatorHeaderParser } from \"./parsing/terminator-header-parser.js\";\n\nimport { streamToBuffer } from \"./stream-utils.js\";\nimport { IFileMedia, IParser, IParsers, FindOpts } from \"./interfaces.js\";\nimport { groupBy, mapValues } from \"./utils.js\";\n\nconst parseHeader = async <T extends IParsers>(\n  Parser: IParser<T>,\n  fileMedia: IFileMedia,\n  offset = 0\n) => {\n  const stream = fileMedia.createReadStream({\n    start: offset,\n    end: offset + Parser.HEADER_SIZE,\n  });\n  const headerBuffer = await streamToBuffer(stream);\n  const parser = new Parser(headerBuffer);\n  return parser.parse() as ReturnType<T[\"parse\"]>;\n};\ninterface ParsedFileChunkMapping {\n  name: string;\n  chunk: RarFileChunk;\n}\ninterface FileChunkMapping extends ParsedFileChunkMapping {\n  fileHead: IFileHeader;\n}\n\nexport class RarFilesPackage extends EventEmitter {\n  rarFileBundle: RarFileBundle;\n  constructor(fileMedias: IFileMedia[]) {\n    super();\n    this.rarFileBundle = makeRarFileBundle(fileMedias);\n  }\n  async parseFile(rarFile: IFileMedia, opts: FindOpts) {\n    const fileChunks: FileChunkMapping[] = [];\n    let fileOffset = 0;\n    const markerHead = await parseHeader(MarkerHeaderParser, rarFile);\n    fileOffset += markerHead.size;\n\n    const archiveHeader = await parseHeader(\n      ArchiveHeaderParser,\n      rarFile,\n      fileOffset\n    );\n    fileOffset += archiveHeader.size;\n\n    let countFiles = 0;\n    let retrievedFiles = 0;\n    while (fileOffset < rarFile.length - TerminatorHeaderParser.HEADER_SIZE) {\n      const fileHead = await parseHeader(FileHeaderParser, rarFile, fileOffset);\n      if (fileHead.type !== 116) {\n        break;\n      }\n      fileOffset += fileHead.headSize;\n      function getFileChunk() {\n          if (fileHead.method !== 0x30) {\n              throw new Error(\"Decompression is not implemented\");\n          }\n          return {\n              name: fileHead.name,\n              fileHead,\n              chunk: new RarFileChunk(\n                rarFile,\n                fileOffset,\n                fileOffset + fileHead.size - 1\n              ),\n          };\n      }\n      if (opts.filter) {\n          if (opts.filter(fileHead.name, countFiles)) {\n              fileChunks.push(getFileChunk());\n              retrievedFiles++;\n              if (opts.hasOwnProperty('maxFiles') && retrievedFiles === opts.maxFiles) {\n                  break;\n              }\n          }\n      } else {\n          fileChunks.push(getFileChunk());\n      }\n      fileOffset += fileHead.size;\n      countFiles++;\n    }\n    this.emit(\"file-parsed\", rarFile);\n    return fileChunks;\n  }\n  async parse(opts: FindOpts): Promise<InnerFile[]> {\n    opts = opts || {};\n    this.emit(\"parsing-start\", this.rarFileBundle);\n    const parsedFileChunks: ParsedFileChunkMapping[][] = [];\n    const { files } = this.rarFileBundle;\n    for (let i = 0; i < files.length; ++i) {\n      const file = files[i]!;\n\n      const chunks = await this.parseFile(file, opts);\n      if (!chunks.length) {\n          this.emit(\"parsing-complete\", []);\n          return [];\n      }\n      const { fileHead, chunk } = chunks[chunks.length - 1]!;\n      const chunkSize = Math.abs(chunk.endOffset - chunk.startOffset);\n      let innerFileSize = fileHead.unpackedSize;\n      parsedFileChunks.push(chunks);\n\n      if (fileHead.continuesInNext) {\n        while (Math.abs(innerFileSize - chunkSize) >= chunkSize) {\n          const nextFile = files[++i]!;\n\n          parsedFileChunks.push([\n            {\n              name: fileHead.name,\n              chunk: new RarFileChunk(\n                nextFile,\n                chunk.startOffset,\n                chunk.endOffset\n              ),\n            },\n          ]);\n          this.emit(\"file-parsed\", nextFile);\n          innerFileSize -= chunkSize;\n        }\n      }\n    }\n\n    const fileChunks = parsedFileChunks.flat();\n\n    const grouped = mapValues(\n      groupBy(fileChunks, (f) => f.name),\n      (value) => value.map((v) => v.chunk)\n    );\n\n    const innerFiles = Object.entries(grouped).map(\n      ([name, chunks]) => new InnerFile(name, chunks)\n    );\n\n    this.emit(\"parsing-complete\", innerFiles);\n    return innerFiles;\n  }\n}\n","const RXX_EXTENSION = /\\.R(\\d\\d)$|.RAR$/i;\nconst RAR_EXTENSION = /.RAR$/i;\nconst PARTXX_RAR_EXTENSION = /.PART(\\d\\d).RAR/i;\nimport { IFileMedia } from \"./interfaces.js\";\n\nconst isPartXXExtension = (fileMedias: IFileMedia[] = []) => {\n  let anyPartXXTypes = fileMedias.filter(\n    (file) => file.name && file.name.match(PARTXX_RAR_EXTENSION)\n  );\n\n  if (anyPartXXTypes.length > 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nclass NumericRarFileBundle {\n  constructor(private fileMedias: IFileMedia[] = []) {\n    if (this.fileMedias.length > 0) {\n      this.filter();\n      this.sort();\n    }\n  }\n  filter() {\n    this.fileMedias = this.fileMedias.filter(\n      (file) => file.name && file.name.match(RXX_EXTENSION)\n    );\n  }\n  sort() {\n    this.fileMedias.sort((first, second) => {\n      if (first.name.match(RAR_EXTENSION)) {\n        return -1;\n      } else if (second.name.match(RAR_EXTENSION)) {\n        return 1;\n      } else {\n        const firstMatch = first.name.match(RXX_EXTENSION);\n        const secondMatch = second.name.match(RXX_EXTENSION);\n        const firstNumber = +((firstMatch && firstMatch[1]) || 0);\n        const secondNumber = +((secondMatch && secondMatch[1]) || 0);\n        return firstNumber - secondNumber;\n      }\n    });\n  }\n\n  get length() {\n    return this.fileMedias.length;\n  }\n  get fileNames() {\n    return this.fileMedias.map((file) => file.name);\n  }\n  get files() {\n    return this.fileMedias;\n  }\n}\n\nclass PartXXRarBundle {\n  constructor(private fileMedias: IFileMedia[] = []) {\n    if (this.fileMedias.length > 0) {\n      this.filter();\n      this.sort();\n    }\n  }\n  filter() {\n    this.fileMedias = this.fileMedias.filter((file) =>\n      file.name.match(PARTXX_RAR_EXTENSION)\n    );\n  }\n  sort() {\n    this.fileMedias.sort((first, second) => {\n      const firstMatch = first.name.match(PARTXX_RAR_EXTENSION);\n      const secondMatch = second.name.match(PARTXX_RAR_EXTENSION);\n      const firstNumber = +((firstMatch && firstMatch[1]) || 0);\n      const secondNumber = +((secondMatch && secondMatch[1]) || 0);\n      return firstNumber - secondNumber;\n    });\n  }\n\n  get length() {\n    return this.fileMedias.length;\n  }\n  get fileNames() {\n    return this.fileMedias.map((file) => file.name);\n  }\n  get files() {\n    return this.fileMedias;\n  }\n}\n\nexport type RarFileBundle = PartXXRarBundle | NumericRarFileBundle;\nexport const makeRarFileBundle = (\n  fileMedias: IFileMedia[] = []\n): RarFileBundle => {\n  return isPartXXExtension(fileMedias)\n    ? new PartXXRarBundle(fileMedias)\n    : new NumericRarFileBundle(fileMedias);\n};\n","import { IFileMedia } from \"./interfaces.js\";\n\nexport class RarFileChunk {\n  constructor(\n    private fileMedia: IFileMedia,\n    public startOffset: number,\n    public endOffset: number\n  ) {}\n  padEnd(endPadding: number) {\n    return new RarFileChunk(\n      this.fileMedia,\n      this.startOffset,\n      this.endOffset - endPadding\n    );\n  }\n  padStart(startPadding: number) {\n    return new RarFileChunk(\n      this.fileMedia,\n      this.startOffset + startPadding,\n      this.endOffset\n    );\n  }\n  get length() {\n    return Math.max(0, this.endOffset - this.startOffset);\n  }\n  getStream() {\n    return this.fileMedia.createReadStream({\n      start: this.startOffset,\n      end: this.endOffset,\n    });\n  }\n}\n","import { Readable, ReadableOptions } from \"stream\";\nimport { RarFileChunk } from \"./rar-file-chunk.js\";\n\nexport class InnerFileStream extends Readable {\n  stream?: NodeJS.ReadableStream;\n  constructor(\n    private rarFileChunks: RarFileChunk[],\n    options?: ReadableOptions\n  ) {\n    super(options);\n  }\n  pushData(data: Uint16Array) {\n    if (!this.push(data)) {\n      this.stream?.pause();\n    }\n  }\n  get isStarted() {\n    return !!this.stream;\n  }\n  next() {\n    const chunk = this.rarFileChunks.shift();\n\n    if (!chunk) {\n      this.push(null);\n    } else {\n      this.stream = chunk.getStream();\n      this.stream?.on(\"data\", (data) => this.pushData(data));\n      this.stream?.on(\"end\", () => this.next());\n    }\n  }\n  override _read() {\n    if (!this.isStarted) {\n      this.next();\n    } else {\n      this.stream?.resume();\n    }\n  }\n}\n","import { Stream, Duplex } from \"stream\";\n\nexport const streamToBuffer = async (stream: Stream | NodeJS.ReadableStream): Promise<Buffer> =>\n  new Promise((resolve, reject) => {\n    const buffers: Uint8Array[] = [];\n    stream.on(\"error\", reject);\n    stream.on(\"data\", (data) => buffers.push(data));\n    stream.on(\"end\", () => resolve(Buffer.concat(buffers)));\n  });\n\nexport const bufferToStream = (buffer: Buffer): Stream => {\n  const stream = new Duplex();\n  stream.push(buffer);\n  stream.push(null);\n  return stream;\n};\n","export function groupBy<T>(arr: T[], fn: (item: T) => any) {\n  return arr.reduce<Record<string, T[]>>((prev, curr) => {\n    const groupKey = fn(curr);\n    const group = prev[groupKey] || [];\n    group.push(curr);\n    return { ...prev, [groupKey]: group };\n  }, {});\n}\n\nexport function sum(arr: number[]) {\n  return arr.reduce((s, n) => s + n);\n}\nexport function mapValues<T extends Object, S>(\n  object: T,\n  mapper: (value: T[keyof T]) => S\n) {\n  return Object.fromEntries(\n    Object.entries(object).map(([key, value]) => [key, mapper(value)])\n  ) as { [key in keyof T]: S };\n}\n","import { IFileMedia, IReadInterval } from \"./interfaces.js\";\nimport { InnerFileStream } from \"./inner-file-stream.js\";\nimport { RarFileChunk } from \"./rar-file-chunk.js\";\nimport { streamToBuffer } from \"./stream-utils.js\";\nimport { sum } from \"./utils.js\";\ntype ChunkMapEntry = {\n  index: number;\n  start: number;\n  end: number;\n  chunk: RarFileChunk;\n};\n\nexport class InnerFile implements IFileMedia {\n  length: number;\n\n  chunkMap: ChunkMapEntry[];\n  constructor(public name: string, private rarFileChunks: RarFileChunk[]) {\n    this.length = sum(rarFileChunks.map((c) => c.length));\n    this.chunkMap = this.calculateChunkMap(rarFileChunks);\n\n    this.name = name;\n  }\n  readToEnd() {\n    return streamToBuffer(\n      this.createReadStream({ start: 0, end: this.length - 1 })\n    );\n  }\n  getChunksToStream(fileStart: number, fileEnd: number) {\n    const { index: startIndex, start: startOffset } =\n      this.findMappedChunk(fileStart);\n    let { index: endIndex, end: endOffset } = this.findMappedChunk(fileEnd);\n\n    const chunksToStream = this.rarFileChunks.slice(startIndex, endIndex + 1);\n\n    const last = chunksToStream.length - 1;\n    const first = 0;\n    chunksToStream[first] = chunksToStream[first]!.padStart(\n      Math.abs(startOffset - fileStart)\n    );\n\n    let diff = Math.abs(endOffset - fileEnd);\n    if (diff === this.rarFileChunks.length) {\n      diff = 0;\n    }\n    if (diff !== 0) {\n      chunksToStream[last] = chunksToStream[last]!.padEnd(diff);\n    }\n\n    return chunksToStream;\n  }\n  createReadStream(interval: IReadInterval) {\n    if (!interval) {\n      interval = { start: 0, end: this.length - 1 };\n    }\n    let { start, end } = interval;\n\n    if (start < 0 || end >= this.length) {\n      throw Error(\"Illegal start/end offset\");\n    }\n\n    return new InnerFileStream(this.getChunksToStream(start, end));\n  }\n  calculateChunkMap(rarFileChunks: RarFileChunk[]) {\n    const chunkMap: ChunkMapEntry[] = [];\n    let index = 0;\n    let fileOffset = 0;\n    for (const chunk of rarFileChunks) {\n      const start = fileOffset;\n      const end = fileOffset + chunk.length;\n      fileOffset = end + 1;\n\n      chunkMap.push({ index, start, end, chunk });\n      index++;\n    }\n\n    return chunkMap;\n  }\n  findMappedChunk(offset: number) {\n    let selectedMap = this.chunkMap[0]!;\n    for (const chunkMapping of this.chunkMap) {\n      if (offset >= chunkMapping.start && offset <= chunkMapping.end) {\n        selectedMap = chunkMapping;\n        break;\n      }\n    }\n    return selectedMap;\n  }\n}\n","export class MarkerHeaderParser {\n  static HEADER_SIZE = 11;\n  constructor(private headerBuffer: Buffer) {}\n\n  parse() {\n    const crc = this.headerBuffer.readUInt16LE(0);\n    const type = this.headerBuffer.readUInt8(2);\n    const flags = this.headerBuffer.readUInt16LE(3);\n    let size = this.headerBuffer.readUInt16LE(5);\n    if ((flags & 0x8000) !== 0) {\n      let addSize = this.headerBuffer.readUint32LE(7);\n      size += addSize || 0;\n    }\n    return { crc, type, flags, size };\n  }\n}\n","interface IArchiveHeader {\n  crc: number;\n  type: number;\n  flags: number;\n  size: number;\n  reserved1: number;\n  reserved2: number;\n}\n\nfunction parseFlags(parsedVars: IArchiveHeader) {\n  return {\n    hasVolumeAttributes: (parsedVars.flags & 0x0001) !== 0,\n    hasComment: (parsedVars.flags & 0x0002) !== 0,\n    isLocked: (parsedVars.flags & 0x0004) !== 0,\n    hasSolidAttributes: (parsedVars.flags & 0x0008) !== 0,\n    isNewNameScheme: (parsedVars.flags & 0x00010) !== 0,\n    hasAuthInfo: (parsedVars.flags & 0x0020) !== 0,\n    hasRecovery: (parsedVars.flags & 0x0040) !== 0,\n    isBlockEncoded: (parsedVars.flags & 0x0080) !== 0,\n    isFirstVolume: (parsedVars.flags & 0x0100) !== 0,\n  };\n}\nexport class ArchiveHeaderParser {\n  static HEADER_SIZE = 13;\n  constructor(private buffer: Buffer) {}\n  parse() {\n    const crc = this.buffer.readUInt16LE(0);\n    const type = this.buffer.readUInt8(2);\n    const flags = this.buffer.readUInt16LE(3);\n    let size = this.buffer.readUInt16LE(5);\n    const reserved1 = this.buffer.readUInt16LE(7);\n    const reserved2 = this.buffer.readUInt32LE(9);\n\n    let vars = { crc, type, flags, size, reserved1, reserved2 };\n\n    return { ...parseFlags(vars), ...vars };\n  }\n}\n","interface IFileHeaderFlags {\n  continuesFromPrevious: boolean;\n  continuesInNext: boolean;\n  isEncrypted: boolean;\n  hasComment: boolean;\n  hasInfoFromPrevious: boolean;\n  hasHighSize: boolean;\n  hasSpecialName: boolean;\n  hasSalt: boolean;\n  isOldVersion: boolean;\n  hasExtendedTime: boolean;\n}\n\ninterface IFileHeaderRaw {\n  crc: number;\n  type: number;\n  flags: number;\n  headSize: number;\n  size: number;\n  unpackedSize: number;\n  host: number;\n  fileCrc: number;\n  timestamp: number;\n  version: number;\n  method: number;\n  nameSize: number;\n  attributes: number;\n  name: string;\n}\n\nexport type IFileHeader = IFileHeaderRaw & IFileHeaderFlags;\nexport class FileHeaderParser {\n  static HEADER_SIZE = 280;\n  offset = 0;\n  constructor(private buffer: Buffer) {}\n  private handleHighFileSize(parsedVars: IFileHeader) {\n    if (parsedVars.hasHighSize) {\n      const highPackSize = this.buffer.readInt32LE(this.offset);\n      this.offset += 4;\n      const highUnpackSize = this.buffer.readInt32LE(this.offset);\n      this.offset += 4;\n      parsedVars.size = highPackSize * 0x100000000 + parsedVars.size;\n      parsedVars.unpackedSize =\n        highUnpackSize * 0x100000000 + parsedVars.unpackedSize;\n    }\n  }\n  private parseFileName(parsedVars: IFileHeaderRaw) {\n    parsedVars.name = this.buffer\n      .subarray(this.offset, this.offset + parsedVars.nameSize)\n      .toString(\"utf-8\");\n  }\n  private parseFlags(parsedVars: IFileHeaderRaw): IFileHeaderFlags {\n    return {\n      continuesFromPrevious: (parsedVars.flags & 0x01) !== 0,\n      continuesInNext: (parsedVars.flags & 0x02) !== 0,\n      isEncrypted: (parsedVars.flags & 0x04) !== 0,\n      hasComment: (parsedVars.flags & 0x08) !== 0,\n      hasInfoFromPrevious: (parsedVars.flags & 0x10) !== 0,\n      hasHighSize: (parsedVars.flags & 0x100) !== 0,\n      hasSpecialName: (parsedVars.flags & 0x200) !== 0,\n      hasSalt: (parsedVars.flags & 0x400) !== 0,\n      isOldVersion: (parsedVars.flags & 0x800) !== 0,\n      hasExtendedTime: (parsedVars.flags & 0x1000) !== 0,\n    };\n  }\n  parse(): IFileHeader {\n    const crc = this.buffer.readUInt16LE(this.offset);\n    this.offset += 2;\n\n    const type = this.buffer.readUInt8(this.offset);\n    this.offset += 1;\n\n    const flags = this.buffer.readUInt16LE(this.offset);\n    this.offset += 2;\n\n    const headSize = this.buffer.readUInt16LE(this.offset);\n    this.offset += 2;\n\n    const size = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n\n    const unpackedSize = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n\n    const host = this.buffer.readUInt8(this.offset);\n    this.offset += 1;\n\n    const fileCrc = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n\n    const timestamp = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n\n    const version = this.buffer.readUInt8(this.offset);\n    this.offset += 1;\n\n    const method = this.buffer.readUInt8(this.offset);\n    this.offset += 1;\n\n    const nameSize = this.buffer.readUInt16LE(this.offset);\n    this.offset += 2;\n\n    const attributes = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n\n    let vars: IFileHeaderRaw = {\n      crc,\n      type,\n      flags,\n      headSize,\n      size,\n      unpackedSize,\n      host,\n      fileCrc,\n      timestamp,\n      version,\n      method,\n      nameSize,\n      attributes,\n      name: \"\",\n    };\n\n    const boolFlags = this.parseFlags(vars);\n    const header = { ...vars, ...boolFlags };\n    this.handleHighFileSize(header);\n    this.parseFileName(header);\n    this.offset = 0;\n    return header;\n  }\n}\n","export class TerminatorHeaderParser {\n  static HEADER_SIZE = 27;\n  constructor(private headerBuffer: Buffer) {}\n  parse() {\n    const crc = this.headerBuffer.readUInt16LE(0);\n    const type = this.headerBuffer.readUInt8(2);\n    const flags = this.headerBuffer.readUInt16LE(3);\n    const size = this.headerBuffer.readUInt16LE(5);\n    return { crc, type, flags, size };\n  }\n}\n","import { basename } from \"path\";\nimport { statSync, createReadStream } from \"fs\";\nimport { IFileMedia, IReadInterval } from \"./interfaces.js\";\n\nexport class LocalFileMedia implements IFileMedia {\n  name: string;\n  length: number;\n  constructor(private path: string) {\n    this.name = basename(path);\n    this.length = statSync(path).size;\n  }\n  createReadStream(interval: IReadInterval) {\n    return createReadStream(this.path, interval);\n  }\n}\n"],"mappings":"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","names":["getFileChunk"]}